(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (factory((global.ReactHooks = {}),global.React));
}(this, (function (exports,React) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var hooksContextStack = [];
    function useCounter() {
        var context = hooksContextStack[hooksContextStack.length - 1];
        var counter = context.counter++;
        return { component: context.component, counter: counter };
    }
    function withContext(component, func) {
        return function () {
            var arguments$1 = arguments;

            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments$1[_i];
            }
            hooksContextStack.push({ component: component, counter: 0 });
            var result = func.apply(void 0, args);
            hooksContextStack.pop();
            return result;
        };
    }

    function bindContexts(contexts, renderFunc) {
        renderFunc();
        var contextsArray = Object
            .getOwnPropertyNames(contexts)
            .map(function (_counter) {
            var counter = parseInt(_counter);
            return [counter, contexts[counter][1]];
        });
        if (contextsArray.length <= 0) {
            return renderFunc;
        }
        else {
            return contextsArray.reduceRight(function (lastRenderFunc, _a) {
                var counter = _a[0], context = _a[1];
                return function () { return (React.createElement(context.Consumer, null, function (value) {
                    contexts[counter] = [value, context];
                    return lastRenderFunc();
                })); };
            }, renderFunc);
        }
    }
    function useContext(context) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        var componentContexts = component.__hooks__.contexts;
        if (!componentContexts.hasOwnProperty(counter)) {
            componentContexts[counter] = [context._currentValue, context];
        }
        return componentContexts[counter][0];
    }

    function inputsChange(oldInputs, newInputs) {
        if (oldInputs && newInputs) {
            if (oldInputs.length > 0 && oldInputs.length > 0) {
                if (oldInputs.length === newInputs.length) {
                    for (var i = 0, l = oldInputs.length; i < l; i++) {
                        if (oldInputs[i] !== newInputs[i]) {
                            return true;
                        }
                    }
                }
                else {
                    return true;
                }
            }
            return false;
        }
        return true;
    }

    function useEffectHandler(effects, counter, effectFunc, inputs) {
        if (!effects.hasOwnProperty(counter)) {
            effects[counter] = [effectFunc, undefined, inputs];
        }
        else {
            var _a = effects[counter], oldInputs = _a[2];
            if (inputsChange(inputs, oldInputs)) {
                effects[counter][0] = effectFunc;
                effects[counter][2] = inputs;
            }
        }
    }
    function runEffects(effects) {
        Object.getOwnPropertyNames(effects).forEach(function (_counter) {
            var counter = parseInt(_counter);
            var _a = effects[counter], effectFunc = _a[0], cleanup = _a[1];
            if (typeof effectFunc === 'function') {
                if (typeof cleanup === 'function') {
                    cleanup();
                }
                var nextCleanup = effectFunc();
                effects[counter][0] = undefined;
                effects[counter][1] = typeof nextCleanup === 'function' ? nextCleanup : undefined;
            }
        });
    }
    function cleanupEffects(effects) {
        Object.getOwnPropertyNames(effects).forEach(function (_counter) {
            var counter = parseInt(_counter);
            var _a = effects[counter], cleanup = _a[1];
            if (typeof cleanup === 'function') {
                cleanup();
            }
            delete effects[counter];
        });
    }
    function useEffect(effectFunc, inputs) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        useEffectHandler(component.__hooks__.effects, counter, effectFunc, inputs);
    }
    function useLayoutEffect(effectFunc, inputs) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        useEffectHandler(component.__hooks__.layoutEffects, counter, effectFunc, inputs);
    }

    function bindComponent(ref, renderFunc) {
        var component = ref.current;
        return withContext(component, function () { return renderFunc(component.props, ref); });
    }
    function withHooks(renderFunc) {
        var HooksComponentClass = /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1(props) {
                var _this = _super.call(this, props) || this;
                _this.state = {};
                _this.__hooks__ = {
                    ref: React.createRef(),
                    setters: {},
                    dispatchers: {},
                    effects: {},
                    layoutEffects: {},
                    refs: {},
                    contexts: {},
                    memos: {},
                    imperativeMethods: undefined,
                };
                _this.__hooks__.ref.current = _this;
                _this.render = bindContexts(_this.__hooks__.contexts, bindComponent(_this.__hooks__.ref, renderFunc));
                return _this;
            }
            class_1.prototype.componentWillMount = function () {
                runEffects(this.__hooks__.layoutEffects);
            };
            class_1.prototype.componentDidMount = function () {
                runEffects(this.__hooks__.effects);
            };
            class_1.prototype.componentWillUpdate = function () {
                runEffects(this.__hooks__.layoutEffects);
            };
            class_1.prototype.componentDidUpdate = function () {
                runEffects(this.__hooks__.effects);
            };
            class_1.prototype.componentWillUnmount = function () {
                cleanupEffects(this.__hooks__.effects);
                cleanupEffects(this.__hooks__.layoutEffects);
            };
            return class_1;
        }(React.Component));
        HooksComponentClass.displayName = renderFunc.name;
        return HooksComponentClass;
    }

    function useState(defaultState) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        var componentState = component.state;
        var componentSetters = component.__hooks__.setters;
        if (!componentState.hasOwnProperty(counter)) {
            if (typeof defaultState === 'function') {
                componentState[counter] = defaultState();
            }
            else {
                componentState[counter] = defaultState;
            }
            componentSetters[counter] = function (state, callback) {
                var _a, _b;
                var componentState = component.state;
                if (typeof state === 'function') {
                    var oldState = componentState[counter];
                    component.setState((_a = {}, _a[counter] = state(oldState), _a), callback);
                }
                else {
                    component.setState((_b = {}, _b[counter] = state, _b), callback);
                }
            };
        }
        return [componentState[counter], componentSetters[counter]];
    }
    function useReducer(reducer, initialState, initialAction) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        var componentState = component.state;
        var componentDispatchers = component.__hooks__.dispatchers;
        if (!componentState.hasOwnProperty(counter)) {
            if (initialAction) {
                componentState[counter] = reducer(initialState, initialAction);
            }
            else {
                componentState[counter] = initialState;
            }
            componentDispatchers[counter] = function (action, callback) {
                var _a;
                var componentState = component.state;
                component.setState((_a = {}, _a[counter] = reducer(componentState[counter], action), _a), callback);
            };
        }
        return [componentState[counter], componentDispatchers[counter]];
    }

    function useRef(initialValue) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        var componentRefs = component.__hooks__.refs;
        if (!componentRefs.hasOwnProperty(counter)) {
            var ref = React.createRef();
            ref.current = initialValue;
            componentRefs[counter] = ref;
        }
        return componentRefs[counter];
    }
    function useImperativeMethods(ref, createInstance, inputs) {
        var component = ref.current;
        if (component) {
            var componentImperativeMethods = component.__hooks__.imperativeMethods;
            if (!componentImperativeMethods) {
                var instance_1 = createInstance();
                Object.getOwnPropertyNames(instance_1).forEach(function (name) {
                    component[name] = instance_1[name];
                });
                component.__hooks__.imperativeMethods = [instance_1, inputs];
            }
            else {
                var oldInstance = componentImperativeMethods[0], oldInputs = componentImperativeMethods[1];
                if (inputsChange(oldInputs, inputs)) {
                    var instance_2 = createInstance();
                    Object.getOwnPropertyNames(oldInstance).forEach(function (name) {
                        delete component[name];
                    });
                    Object.getOwnPropertyNames(instance_2).forEach(function (name) {
                        component[name] = instance_2[name];
                    });
                    component.__hooks__.imperativeMethods = [instance_2, inputs];
                }
            }
        }
    }

    function useMemo(computedFunc, inputs) {
        var _a = useCounter(), component = _a.component, counter = _a.counter;
        var componentMemos = component.__hooks__.memos;
        if (!componentMemos.hasOwnProperty(counter)) {
            componentMemos[counter] = [computedFunc(), inputs];
        }
        else {
            var _b = componentMemos[counter], oldInputs = _b[1];
            if (inputsChange(oldInputs, inputs)) {
                componentMemos[counter] = [computedFunc(), inputs];
            }
        }
        return componentMemos[counter][0];
    }
    function useCallback(callback, inputs) {
        return useMemo(function () { return callback; }, inputs);
    }

    exports.withHooks = withHooks;
    exports.useState = useState;
    exports.useReducer = useReducer;
    exports.useEffect = useEffect;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useContext = useContext;
    exports.useRef = useRef;
    exports.useImperativeMethods = useImperativeMethods;
    exports.useMemo = useMemo;
    exports.useCallback = useCallback;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-hooks.min.js.map
